# 新股发行信息获取系统 - 设计文档

## 1. 系统架构

### 1.1 整体架构

系统采用简洁的三文件架构设计，便于部署和维护：

```
┌─────────────────────────────────────┐
│      主入口 (main_simple.py)        │  流程编排
├─────────────────────────────────────┤
│      服务模块 (services.py)         │  业务逻辑
│  - DataFetcher    (数据获取)        │
│  - DataProcessor  (数据处理)        │
│  - MarkdownFormatter (格式化)       │
│  - setup_logger   (日志配置)        │
├─────────────────────────────────────┤
│      数据模型 (models.py)           │  数据结构
│  - NewStockInfo    (新股信息)       │
└─────────────────────────────────────┘

设计理念: 简洁优先，易于部署
输出到控制台，由 n8n 读取并推送
```

### 1.2 目录结构

```
F:\github\person_project\new-index-info/
├── .gitignore                    # Git忽略文件
├── pyproject.toml                # 项目依赖配置
├── README.md                     # 项目说明文档
├── DEPLOY_README.md              # 部署说明（根目录副本）
├── deploy/                       # 主程序目录 ⭐
│   ├── models.py                 # 数据模型（约100行）
│   ├── services.py               # 所有服务模块（约500行）
│   ├── main_simple.py            # 主入口（约70行）
│   ├── requirements.txt          # 依赖列表
│   └── DEPLOY_README.md          # 部署说明
├── scripts/                      # 启动脚本
│   ├── run.sh                    # Linux/Mac启动脚本
│   └── run.bat                   # Windows启动脚本
├── logs/                         # 日志输出目录（自动创建）
├── docs/                         # 正式文档
│   └── 需求文档.md
└── discuss/                      # 讨论文档
    └── 设计文档.md
```

### 1.3 架构设计原则

1. **简洁优先**: 仅保留必要的 3 个 Python 文件
2. **易于部署**: 单目录结构，复制即可运行
3. **职责清晰**: 每个文件职责单一明确
4. **性能优化**: 先筛选后补充详细信息，避免不必要的 API 调用
5. **日志完善**: 详细的日志记录，便于调试

## 2. 数据模型设计

### 2.1 新股信息模型 (NewStockInfo)

```python
@dataclass
class NewStockInfo:
    """新股信息模型

    包含新股发行的所有关键信息
    """
    # 基本信息
    stock_code: str                    # 股票代码（如 "301001"）
    stock_name: str                    # 股票名称（如 "XYZ科技"）
    issue_date: datetime               # 发行日期
    subscription_code: str             # 申购代码（如 "301001"）

    # 发行相关
    issue_price: Optional[float]       # 发行价格（元，可能为None表示待定）
    issue_quantity: Optional[float]    # 发行数量（万股）
    subscription_limit: Optional[float] # 申购上限（万股）
    lottery_rate: Optional[str]        # 中签率（%，如 "0.03"）

    # 上市相关
    listing_date: Optional[datetime]   # 上市日期（可能为None）
    market: str                        # 上市地点（详细分类：上海-主板、上海-科创板、深圳-主板、深圳-创业板、北交所）

    # 公司信息
    company_intro: str                 # 公司简介
    industry: str                      # 所属行业

    # 辅助方法
    def get_market_code(self) -> str:
        """获取市场代码（"SH"或"SZ"）"""

    def is_price_determined(self) -> bool:
        """判断发行价格是否已确定"""

    def get_formatted_price(self) -> str:
        """获取格式化的发行价格字符串"""
```

### 2.2 设计决策

**为什么选择 dataclass 而不是 Pydantic？**
- 更轻量：dataclass 是 Python 内置，无需额外依赖
- 足够使用：当前场景不需要复杂的验证逻辑
- 性能更好：dataclass 的运行时开销更小

**为什么使用 Optional 类型？**
- 新股数据的某些字段可能为空（如发行价格待定）
- 明确标注可选字段，提高代码可读性
- 避免 None 相关的错误

## 3. 核心模块设计

### 3.1 日志工具 (logger.py)

**职责**: 提供统一的日志记录功能

**设计要点**:
- 控制台 + 文件双输出
- 按日期分割日志文件
- 统一的日志格式
- 全局单例模式

**关键方法**:
```python
def setup_logger(name: str, level: int, log_dir: Path) -> Logger
def get_logger() -> Logger
```

### 3.2 数据获取服务 (data_fetcher.py)

**职责**: 使用 akshare API 获取新股数据

**核心流程**:
```
1. 调用 ak.stock_new_em() 获取原始数据
2. 解析 DataFrame 字段映射
3. 转换为 NewStockInfo 对象列表
4. 异常处理和重试
```

**关键方法**:
```python
class DataFetcher:
    def fetch_new_stocks(self) -> List[NewStockInfo]
    def _parse_dataframe(self, df: pd.DataFrame) -> List[NewStockInfo]
    def _parse_date(self, date_str: str) -> Optional[datetime]
    def _parse_float(self, value: any) -> Optional[float]
    def _determine_market(self, stock_code: str) -> str
```

**字段映射** (根据实际使用的 akshare API):
```
证劵代码 → stock_code
证券简称 → stock_name
申购日期 → issue_date
申购代码 → subscription_code
发行价 → issue_price
发行总数 → issue_quantity
申购上限 → subscription_limit
中签率 → lottery_rate
上市日期 → listing_date
公司简介 → company_intro
所属行业 → industry
```

**市场分类逻辑**:
```python
def _determine_market(self, stock_code: str) -> str:
    """根据股票代码前缀判断市场"""
    if stock_code.startswith("60"):
        return "上海-主板"
    elif stock_code.startswith("68"):
        return "上海-科创板"
    elif stock_code.startswith("00"):
        return "深圳-主板"
    elif stock_code.startswith("30"):
        return "深圳-创业板"
    elif stock_code.startswith(("8", "4", "92", "93")):
        return "北交所"
    return ""
```

**详细信息补充**:
```python
def _enrich_stock_info(self, stocks: List[NewStockInfo]) -> List[NewStockInfo]:
    """补充行业和公司简介信息（性能优化：仅对筛选后的股票调用）"""
    # 调用 ak.stock_profile_cninfo(symbol) 获取详细信息
    # 更新 stock.industry 和 stock.company_intro
```

### 3.3 数据处理服务 (data_processor.py)

**职责**: 对获取的数据进行筛选和处理

**核心流程**:
```
1. 数据验证（检查必填字段）
2. 时间筛选（未来10天）
3. 按日期分组
```

**关键方法**:
```python
class DataProcessor:
    def filter_future_stocks(self, stocks: List[NewStockInfo]) -> List[NewStockInfo]
    def group_by_date(self, stocks: List[NewStockInfo]) -> dict
    def validate_data(self, stocks: List[NewStockInfo]) -> List[NewStockInfo]
```

**时间筛选逻辑**:
```python
today = datetime.now().date()
end_date = today + timedelta(days=10)
# 筛选条件: today <= issue_date <= end_date
```

### 3.4 Markdown 格式化服务 (formatter.py)

**职责**: 将新股信息格式化为 Markdown 并输出到控制台

**输出格式**:
```markdown
# 新股发行信息

**生成时间**: 2026-01-02 10:00:00
**新股数量**: 3 只

---

## 2026-01-05

### XYZ科技（301001）

| 项目 | 信息 |
|------|------|
| **申购代码** | 301001 |
| **申购日期** | 2026-01-05 | ✅ 新增
| **发行价格** | 15.80元 |
| **发行数量** | 5000万股 |
| **申购上限** | 15万股 |
| **中签率** | 0.03% |
| **上市日期** | 2026-01-10 |
| **上市地点** | 深圳-创业板 | ✅ 更新为详细分类
| **所属行业** | 软件/互联网 | ✅ 已实现

**公司简介**: | ✅ 已实现
XXX...
```

**输出说明**: Markdown 内容通过 print() 输出到控制台（标准输出），可被 n8n 等工具读取

**关键方法**:
```python
class MarkdownFormatter:
    def format_new_stocks(self, stocks: List[NewStockInfo]) -> str
    def _format_stock(self, stock: NewStockInfo) -> List[str]
    def _format_empty(self) -> str
```

## 4. 主流程设计

### 4.1 主入口 (main.py)

**核心流程**:
```python
def main():
    # 1. 设置日志
    logger = setup_logger()

    # 2. 获取数据
    fetcher = DataFetcher()
    stocks = fetcher.fetch_new_stocks()

    # 3. 处理数据
    processor = DataProcessor(future_days=10)
    valid_stocks = processor.validate_data(stocks)
    future_stocks = processor.filter_future_stocks(valid_stocks)

    # 4. 补充详细信息（只对筛选后的新股）✅ 性能优化
    if future_stocks:
        future_stocks = fetcher._enrich_stock_info(future_stocks)

    # 5. 格式化输出
    formatter = MarkdownFormatter()
    markdown = formatter.format_new_stocks(future_stocks)

    # 6. 输出到控制台（供 n8n 读取）
    print(markdown)

    # 7. 记录日志
    logger.info(f"获取到 {len(future_stocks)} 只新股")
```

**设计原则**:
- 保持简洁（不超过100行）
- 只负责流程编排
- 异常处理和日志记录

## 5. 运行脚本设计

### 5.1 Windows 脚本 (run.bat)

```batch
@echo off
cd /d "%~dp0\.."

if not exist ".venv" (
    echo Error: Virtual environment not found
    pause
    exit /b 1
)

REM Check if deploy/main_simple.py exists
if not exist "deploy\main_simple.py" (
    echo Error: deploy\main_simple.py not found
    pause
    exit /b 1
)

REM Change to deploy directory
cd deploy

REM Run application
echo Starting application...
"..\.venv\Scripts\python.exe" main_simple.py %*

pause
```

### 5.2 Linux/Mac 脚本 (run.sh)

```bash
#!/bin/bash
cd "$(dirname "$0")/.."

if [ ! -d ".venv" ]; then
    echo "错误: 虚拟环境不存在，请先运行: uv venv"
    exit 1
fi

# 检查 deploy/main_simple.py 是否存在
if [ ! -f "deploy/main_simple.py" ]; then
    echo "错误: deploy/main_simple.py 不存在"
    exit 1
fi

# 进入 deploy 目录
cd deploy

# 激活虚拟环境并运行应用
if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "win32" ]]; then
    # Windows (Git Bash)
    echo "启动应用..."
    ../.venv/Scripts/python.exe main_simple.py "$@"
else
    # Linux/Mac
    echo "启动应用..."
    source ../.venv/bin/activate
    python main_simple.py "$@"
fi
```

## 6. 错误处理设计

### 6.1 异常分类

| 异常类型 | 处理策略 |
|---------|---------|
| 网络异常 | 重试3次，记录日志 |
| 数据解析异常 | 跳过单条数据，记录警告 |
| 输出异常 | 记录错误，保证程序正常退出 |

### 6.2 日志级别

- **DEBUG**: 详细的调试信息
- **INFO**: 正常流程信息
- **WARNING**: 可恢复的异常（如单条数据解析失败）
- **ERROR**: 错误但程序可继续（如推送失败）
- **CRITICAL**: 严重错误导致程序退出

## 7. 实现步骤

### 阶段一：项目初始化
1. 创建目录结构
2. 初始化 uv 虚拟环境
3. 创建配置文件（pyproject.toml、.gitignore）

### 阶段二：基础设施层
1. 实现日志工具 (logger.py)
2. 实现数据模型 (new_stock.py)

### 阶段三：核心服务层
1. 实现数据获取服务 (data_fetcher.py)
2. 实现数据处理服务 (data_processor.py)
3. 实现格式化服务 (formatter.py)

### 阶段四：主流程和脚本
1. 实现主入口 (main.py)
2. 创建运行脚本 (run.bat、run.sh)

### 阶段五：测试和文档
1. 功能测试
2. 异常处理测试
3. 编写 README.md

## 8. 依赖包管理

### 8.1 核心依赖

```
[project]
dependencies = [
    "akshare>=1.17.80",      # 财经数据接口
    "pandas>=2.3.0",          # 数据处理
]
```

### 8.2 包管理策略

- 使用 uv 作为包管理工具
- 虚拟环境目录: .venv
- 初始化命令: `uv venv`
- 安装依赖: `uv pip install -e .`

## 9. 安全设计

### 9.1 设计简化

- 无需存储敏感信息（webhook 由 n8n 管理）
- 无需环境变量配置
- 配置极简，降低出错风险

### 9.2 输出安全

- Markdown 输出经过格式化，避免注入风险
- 所有数据经过验证和转义

## 10. 可扩展性设计

### 10.1 数据源扩展

通过接口抽象，可以轻松添加新的数据源：
```python
class DataFetcher(ABC):
    @abstractmethod
    def fetch_new_stocks(self) -> List[NewStockInfo]:
        pass

class AkshareFetcher(DataFetcher):
    # akshare 实现

class TushareFetcher(DataFetcher):
    # tushare 实现
```

### 10.2 输出格式扩展

当前只支持 Markdown，未来可添加其他格式（JSON、XML等）：
```python
class Formatter(ABC):
    @abstractmethod
    def format(self, stocks: List[NewStockInfo]) -> str:
        pass

class MarkdownFormatter(Formatter):
    # Markdown 实现
```

## 11. 性能优化

### 11.1 网络优化
- 设置合理的超时时间（10秒）
- 失败重试机制（最多3次）
- 连接池复用

### 11.2 数据处理优化
- 使用 pandas 进行高效数据处理
- 批量数据转换
- 避免重复计算

## 12. 测试策略

### 12.1 单元测试
- 每个服务模块独立测试
- Mock 外部依赖（akshare、钉钉API）

### 12.2 集成测试
- 端到端流程测试
- 异常场景测试

### 12.3 手动测试
- 真实数据测试
- 控制台输出验证
- n8n 集成测试

## 13. 部署指南

### 13.1 环境准备
```bash
# 1. 克隆项目
git clone <repo_url>
cd new-index-info

# 2. 创建虚拟环境
uv venv
# 或使用 python -m venv .venv

# 3. 安装依赖
uv pip install akshare pandas
# 或使用 pip install akshare pandas
```

### 13.2 本地运行
```bash
# Windows
scripts\run.bat

# Linux/Mac
bash scripts/run.sh
```

### 13.3 集成到 n8n
在 n8n 中使用 "Execute Command" 节点：
- 命令: `cd /path/to/new-index-info/deploy && ../.venv/bin/python main_simple.py`
- 读取标准输出作为后续节点的输入

### 13.4 部署到服务器

项目设计简洁，只需复制 3 个文件即可在服务器上运行：

**文件清单**:
- `models.py` - 数据模型（约 100 行）
- `services.py` - 所有服务模块（约 500 行）
- `main_simple.py` - 主入口（约 70 行）

**部署步骤**:
```bash
# 1. 复制文件到服务器
scp deploy/*.py user@server:/path/to/project/
scp deploy/requirements.txt user@server:/path/to/project/

# 2. 安装依赖
ssh user@server
cd /path/to/project
pip install -r requirements.txt

# 3. 运行
python main_simple.py
```

**适用场景**: 简洁的 3 文件结构，易于部署和维护

## 14. 维护指南

### 14.1 日志查看
- 日志位置: logs/new-index-info-YYYY-MM-DD.log
- 按日期分割，方便查找

### 14.2 常见问题

**问题1**: 获取不到数据
- 检查网络连接
- 检查 akshare API 是否变化

**问题2**: 输出格式不正确
- 检查 Markdown 格式化逻辑
- 确保特殊字符已转义

**问题3**: n8n 无法读取输出
- 检查标准输出是否正确
- 确保 print() 语句在最后执行

## 15. 关键设计决策说明

### 15.1 为什么选择三文件架构？
- **简洁**: 只需 3 个文件，易于理解和维护
- **部署**: 复制即用，无需复杂目录结构
- **效率**: 减少文件间的 import 开销
- **实用**: 对于小规模项目，过度分层反而增加复杂度

### 15.2 为什么使用 dataclass？
- **轻量**: Python 内置，无额外依赖
- **高效**: 运行时开销小
- **简洁**: 代码简洁易读
- **类型安全**: 支持类型提示

### 15.3 为什么直接输出到控制台？
- **简化**: 不需要复杂的配置管理
- **灵活**: n8n 等工具可以自由处理输出
- **解耦**: 输出和推送逻辑分离
- **通用**: 标准输出是跨平台的通用接口

### 15.4 性能优化策略
1. **先筛选后补充**: 只对筛选后的 2-3 只新股补充详细信息，而非全部 531 只
2. **避免重复请求**: 使用 pandas 批量处理数据
3. **合理的超时**: 网络请求设置 10 秒超时
4. **日志按日期分割**: 避免单个日志文件过大

### 15.5 代码质量保证
1. **单一职责**: 每个类只负责一项功能
2. **清晰命名**: 变量和函数名称见名知意
3. **异常处理**: 完善的 try-except 和日志记录
4. **类型标注**: 使用 dataclass 确保类型安全
5. **避免过度设计**: 实用优先，不引入不必要的抽象
